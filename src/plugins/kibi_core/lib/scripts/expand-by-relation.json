{
  "title": "Expand by relation",
  "description": "Expands the selected nodes using the selected relations",
  "scriptSource": "function beforeAll(graphModel, graphSelection) {\n    const relations = f.getKibiRelations();\n    \n    let relevantNodes = [];\n    if(graphSelection.length === 0) {\n        _.each(graphModel.nodes, function(node) {\n            relevantNodes.push(node.id);\n        });\n    } else {\n        relevantNodes = graphSelection;\n    }\n    \n    let relevantRel = {};\n    _.each(relations, function(relation) {\n        _.each(relevantNodes, function (nodeId) {\n            var from = new RegExp(relation.indices[0].indexPatternId);\n            var to = new RegExp(relation.indices[1].indexPatternId);\n\n            let nodeIndex = nodeId.substring(0, nodeId.indexOf('/'));\n            if (from.test(nodeIndex) || to.test(nodeIndex)) {\n                if(!relevantRel[relation.id]) {\n                    relevantRel[relation.id] = relation;\n                }\n            }\n        });\n    });\n    \n    console.log(relevantRel);\n    let html = '<div>';\n    _.each(relevantRel, function (rel) {\n         html = html + '<input type=\"checkbox\" ng-model=\\'relations[\"' + rel.label + '\"]\\'> ' + rel.label + '</input></br>';\n    });\n        \n    html = html + '</div>';\n    f.openModal('Select the relation you want to expand', html);\n\n    return {\n        model: null,\n        selection: null\n    };\n}\n\nfunction onModalOk(scope, graphModel) {\n    let selectedRel = [];\n\n    for (var rel in scope.relations) {\n        if (scope.relations.hasOwnProperty(rel)) {\n            if (scope.relations[rel]) {\n                selectedRel.push(rel);\n            }\n        }\n    }\n\n    return selectedRel;\n}\n\nfunction afterModalClosed(graphModel, graphSelection, onOkModalResult) {\n    let selection;\n    if (graphSelection && graphSelection.length > 0) {\n        selection = graphSelection;\n    } else {\n        selection = [];\n        _.each(graphModel.nodes, function (node) {\n           selection.push(node.id); \n        });\n    }\n    \n    let query = 'g.V(' + JSON.stringify(selection)\n            + ').bothE().as(\"e\").bothV().as(\"v\").properties().select(\"e\", \"v\").mapValues().dedup()';\n\n    let relationsSet = new Set(onOkModalResult);\n    return f.executeGremlinQuery(query).then(function (results) {\n        let filteredResults = [];\n        let nodeIdSet = new Set();\n        \n        _.each(results, function (item) {\n            if (item.type === 'edge') {\n                if (relationsSet.has(item.label)) {\n                    nodeIdSet.add(item.inV);\n                    nodeIdSet.add(item.outV);\n                    filteredResults.push(item);\n                }\n            }\n        });\n        \n        _.each(results, function (item) {\n            if (item.type === 'vertex') {\n                if (nodeIdSet.has(item.id)) {\n                    filteredResults.push(item);\n                }\n            }\n        });\n        \n        f.addResultsToGraph(filteredResults);\n    });\n}",
  "version": 1,
  "type": "contextual",
  "kibanaSavedObjectMeta": {
    "searchSourceJSON": "{}"
  }
}
